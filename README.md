# Типы данных
## Dating (datyng.py)
Задача 1
Мы делаем MVP dating-сервиса, и у нас есть список парней и девушек — их число может варьироваться:

```
boys = ['Peter', 'Alex', 'John', 'Arthur', 'Richard']
girls = ['Kate', 'Liza', 'Kira', 'Emma', 'Trisha']
```    

Выдвигаем гипотезу: лучшие рекомендации мы получим, если просто отсортируем имена по алфавиту и познакомим людей с одинаковыми индексами после сортировки.
«Познакомить» пары нам поможет функция `zip`. В цикле распакуем zip-объект и выведем информацию в виде:

```
Идеальные пары:
Alex и Emma
Arthur и Kate
John и Kira
Peter и Liza
Richard и Trisha
```    

**Внимание. Если количество людей в списках будет не совпадать, то мы никого знакомить не будем и выведем пользователю предупреждение, что кто-то может остаться без пары.**

## Cooking (cook_book.py)
Задание 1
Есть структура данных `cook_book`, в которой хранится информация об ингредиентах блюд и их количестве в расчёте на одну порцию:
```
cook_book = [
  ['салат',
      [
        ['картофель', 100, 'гр.'],
        ['морковь', 50, 'гр.'],
        ['огурцы', 50, 'гр.'],
        ['горошек', 30, 'гр.'],
        ['майонез', 70, 'мл.'],
      ]
  ],
  ['пицца',  
      [
        ['сыр', 50, 'гр.'],
        ['томаты', 50, 'гр.'],
        ['тесто', 100, 'гр.'],
        ['бекон', 30, 'гр.'],
        ['колбаса', 30, 'гр.'],
        ['грибы', 20, 'гр.'],
      ],
  ],
  ['фруктовый десерт',
      [
        ['хурма', 60, 'гр.'],
        ['киви', 60, 'гр.'],
        ['творог', 60, 'гр.'],
        ['сахар', 10, 'гр.'],
        ['мед', 50, 'мл.'],  
      ]
  ]
]
```    
и переменная, в которой хранится количество людей, на которых нужно приготовить эти блюда:
```
person = 5
```

Нужно вывести пользователю список покупок необходимого количества ингредиентов для приготовления блюд на определённое число персон в следующем виде:

```
Салат:
картофель, 500гр.
морковь, 250гр.
огурцы, 250гр.
горошек, 150гр.
майонез, 350мл.

Пицца:
сыр, 250гр.
томаты, 250гр.
тесто, 500гр.
бекон, 150гр.
колбаса, 150гр.
грибы, 100гр.

Фруктовый десерт:
хурма, 300гр.
киви, 300гр.
творог, 300гр.
сахар, 50гр.
мед, 250мл.
```
**Внимание. Реализация не должна зависеть от количества блюд, их названий и количества ингредиентов в них.**
# Функции 
## "Секретарь" (secretary.py)

Я работаю секретарем и мне постоянно приходят различные документы. Я должен быть очень внимателен чтобы не потерять ни один документ. Каталог документов хранится в следующем виде:

```
      documents = [
        {"type": "passport", "number": "2207 876234", "name": "Василий Гупкин"},
        {"type": "invoice", "number": "11-2", "name": "Геннадий Покемонов"},
        {"type": "insurance", "number": "10006", "name": "Аристарх Павлов"}
      ]
```    
Перечень полок, на которых находятся документы хранится в следующем виде:

```
      directories = {
        '1': ['2207 876234', '11-2'],
        '2': ['10006'],
        '3': []
      }
```
## Задача №1
Необходимо реализовать пользовательские команды, которые будут выполнять следующие функции:

* `p` – people – команда, которая спросит номер документа и выведет имя человека, которому он принадлежит;
* `s` – shelf – команда, которая спросит номер документа и выведет номер полки, на которой он находится;  
*Правильно обработайте ситуации, когда пользователь будет вводить несуществующий документ*.
* `l`– list – команда, которая выведет список всех документов в формате `passport "2207 876234" "Василий Гупкин"`;
* `a` – add – команда, которая добавит новый документ в каталог и в перечень полок, спросив его номер, тип, имя владельца и номер полки, на котором он будет храниться. *Корректно обработайте ситуацию, когда пользователь будет пытаться добавить документ на несуществующую полку*.

**Внимание**: p, s, l, a - это пользовательские команды, а не названия функций. Функции должны иметь выразительное название, передающие её действие.

* `d` – delete – команда, которая спросит номер документа и удалит полностью документ из каталога и его номер из перечня полок. *Предусмотрите сценарий, когда пользователь вводит несуществующий документ*;
* `m` – move – команда, которая спросит номер документа и целевую полку и переместит его с текущей полки на целевую. *Корректно обработайте кейсы, когда пользователь пытается переместить несуществующий документ или переместить документ на несуществующую полку*;
* `as` – add shelf – команда, которая спросит номер новой полки и добавит ее в перечень. *Предусмотрите случай, когда пользователь добавляет полку, которая уже существует*.;

# Классы
## "Ферма Дядюшки Джо" (ClassTask.py)
Вы приехали помогать на ферму Дядюшки Джо и видите вокруг себя множество разных животных:
* гусей "Серый" и "Белый"
* корову "Маньку"
* овец "Барашек" и "Кудрявый"
* кур "Ко-Ко" и "Кукареку"
* коз "Рога" и "Копыта"
* и утку "Кряква"
​
Со всеми животными вам необходимо как-то взаимодействовать:
* кормить
* корову и коз доить
* овец стричь
* собирать яйца у кур, утки и гусей
* различать по голосам(коровы мычат, утки крякают и т.д.)
​
## Задание 1:
Нужно реализовать классы животных и определить методы взаимодействия с животными.  
​Для каждого животного из списка должен существовать экземпляр класса.  
Каждое животное требуется накормить и подоить/постричь/собрать яйца, если надо.
​## Задание 2:
У каждого животного должно быть определено имя(```self.name```) и вес(```self.weight```). 
- Необходимо посчитать общий вес всех животных(экземпляров класса);
- Вывести название самого тяжелого животного.
## Задание 3:
Вам нужно реализовать родительский класс для всех животных и вынести общее поведение в него.  
От родительского класса должны будут отнаследоваться все остальные животные.  
В родительском классе должно быть 2-3 общих класса и общие поля.
## Задание 4:
Используя методы из родительского класса, вызовите их в цикле у списка всех животных.

## "Аудиоколлекция" (audio.py)
Необходимо уметь хранить информацию по альбомам и трекам в них. Это можно сделать, используя классы ```Album``` и ```Track```.  
У класса ```Track``` есть поля:
* Название;
* Длительность в минутах(используется тип данных ```int```).
И метод ```show```, выводящий информацию по треку в виде ```<Название-Длительность>```.  

У класса ```Album``` есть поля:
* Название альбома
* Группа
* Список треков
И три метода:
* ```get_tracks``` - выводит информацию по всем трекам(используется метод ```show```).
* ```add_track``` - добавление нового трека в список треков.
* ```get_duration``` - выводит длительность всего альбома.

## Задание 1:
Создать 2 альбома с 3 треками. Для каждого вывести его длительность.
Попробуйте получить более подробную информацию о них, опираясь на примеры использования методов в описании заданий:

## Задание 2:
Вместо метода ```show``` использовать магический метод ```__str__``` у трека для вывода информации по треку.  
Пример использования
```python
print(track1)
Bohemian rhapsody-6min
```
У Класса Альбом также реализовать магический метод ```__str__``` для вывода информации по альбому и его треков.
Пример использования
```python
print(my_album)
Name group: Queen
Name album: Bohemian rhapsody
Tracks:
	Bohemian rhapsody-6min
	The show must go on-4min
```
## Задание 3:
Реализовать возможность сравнивать треки по длительности. Для этого нужно будет определить магические методы.
Пример
```python
track1 = Track('Bohemian rhapsody', 6)
track2 = Track('The show must go on', 4)
track1 > track2
True
```
## «Открытие и чтение файла, запись в файл»

Необходимо написать программу для кулинарной книги.

Список рецептов должен храниться в отдельном файле в следующем формате:

```
Название блюда
Количество ингредиентов в блюде
Название ингредиента | Количество | Единица измерения
Название ингредиента | Количество | Единица измерения
...
...
Омлет
3
Яйцо | 2 | шт
Молоко | 100 | мл
Помидор | 2 | шт

```
* В одном файле может быть произвольное количество блюд.
* Читать список рецептов из этого файла.
* Соблюдайте кодстайл, разбивайте новую логику на функции и не используйте глобальных переменных.

## Задача №1
Должен получится следующий словарь
```python
cook_book = {
  'Омлет': [
    {'ingredient_name': 'Яйцо', 'quantity': 2, 'measure': 'шт.'},
    {'ingredient_name': 'Молоко', 'quantity': 100, 'measure': 'мл'},
    {'ingredient_name': 'Помидор', 'quantity': 2, 'measure': 'шт'}
    ],
  'Утка по-пекински': [
    {'ingredient_name': 'Утка', 'quantity': 1, 'measure': 'шт'},
    {'ingredient_name': 'Вода', 'quantity': 2, 'measure': 'л'},
    {'ingredient_name': 'Мед', 'quantity': 3, 'measure': 'ст.л'},
    {'ingredient_name': 'Соевый соус', 'quantity': 60, 'measure': 'мл'}
    ],
  'Запеченный картофель': [
    {'ingredient_name': 'Картофель', 'quantity': 1, 'measure': 'кг'},
    {'ingredient_name': 'Чеснок', 'quantity': 3, 'measure': 'зубч'},
    {'ingredient_name': 'Сыр гауда', 'quantity': 100, 'measure': 'г'},
    ]
  }
```

## Задача №2
Нужно написать функцию, которая на вход принимает список блюд из cook_book и количество персон для кого мы будем готовить
```python
get_shop_list_by_dishes(dishes, person_count)
```
На выходе мы должны получить словарь с названием ингредиентов и его количества для блюда.
Например, для такого вызова
```python
get_shop_list_by_dishes(['Запеченный картофель', 'Омлет'], 2)
```
Должен быть следующий результат:
```
{
  'Картофель': {'measure': 'кг', 'quantity': 2},
  'Молоко': {'measure': 'мл', 'quantity': 200},
  'Помидор': {'measure': 'шт', 'quantity': 4},
  'Сыр гауда': {'measure': 'г', 'quantity': 200},
  'Яйцо': {'measure': 'шт', 'quantity': 4},
  'Чеснок': {'measure': 'зубч', 'quantity': 6}
}
```
**Обратите внимание, что ингредиенты могут повторяться**
## Задача №3
В папке лежит некоторое количество файлов. Считайте, что их количество и имена вам заранее известны, пример для выполнения домашней работы можно взять [тут](https://github.com/netology-code/py-homework-basic-files/tree/master/2.4.files/sorted)  

Необходимо объединить их в один по следующим правилам:
1. Содержимое исходных файлов в результирующем файле должно быть отсортировано по количеству строк в них (то есть первым нужно записать файл с наименьшим количеством строк, а последним - с наибольшим)
2. Содержимое файла должно предваряться служебной информацией на 2-х строках: имя файла и количество строк в нем

**Пример**
Даны файлы: 
1.txt
```
Строка номер 1 файла номер 1
Строка номер 2 файла номер 1
```

2.txt
```
Строка номер 1 файла номер 2
```

Итоговый файл: 
```
2.txt
1
Строка номер 1 файла номер 2
1.txt
2
Строка номер 1 файла номер 1
Строка номер 2 файла номер 1
```


## Задача №4
Для подготовки к следующей лекции прочитайте про [менеджер контекста](https://habr.com/ru/post/196382/).

---
## Как сдавать задачи
Пишите код в IDE (рекомендуем [Pycharm](https://www.jetbrains.com/ru-ru/pycharm/download/#section=windows), версия Community, инструкцию по установке вы найдете на сайте).  
- Почему лучше работать в IDE? — Ускоряет работу, есть подсветка ошибок, отладка по шагам.  
- Для более подробной информации изучите [инструкцию по работе с Pycharm](https://github.com/netology-code/guides/blob/master/python/Pycharm.md).  
- Опирайтесь на принятые [правила оформления кода](https://github.com/netology-code/codestyle/tree/master/python), чтобы выработать привычку писать профессионально. При несоблюдении принятого стиля домашние задания могут быть отправлены на доработку. 

1. Инициализируйте на своём компьютере пустой Git-репозиторий
2. Добавьте в этот же каталог необходимые файлы
3. Сделайте необходимые коммиты
4. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
5. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
6. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](http://netology.ru/)
7. Задачи, отмеченные как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)
8. Любые вопросы по решению задач задавайте в чате вашей группы, но мы не сможем проверить или помочь, если вы пришлете:
* архивы;
* скриншоты кода;
* теоретический рассказ о возникших проблемах.